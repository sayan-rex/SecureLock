#include "registers.h"
#include <math.h>
#include <string.h>

#define PI              3.14159265358979323846f
#define ASM330LHB_ADDR  0x6B

// IMU Register Definitions
#define ASM330LHB_WHO_AM_I   0x0F
#define ASM330LHB_CTRL1_XL   0x10
#define ASM330LHB_CTRL2_G    0x11
#define ASM330LHB_OUTX_L_A   0x28

// Simple Delay Function
void delay(uint32_t ms) {
    for (volatile uint32_t i = 0; i < ms * 2000; i++);
}

// Initialize System Clock (HSI 16MHz)
void SystemClock_Config(void) {
    RCC->CR |= (1 << 0);        // Enable HSI
    while (!(RCC->CR & (1 << 1))); // Wait for HSI ready
    RCC->CFGR &= ~(3 << 0);     // Set HSI as system clock
}

// Initialize I2C1 (PB6: SCL, PB7: SDA)
void I2C1_Init(void) {
    RCC->AHB1ENR |= (1 << 1);   // Enable GPIOB clock
    RCC->APB1ENR |= (1 << 21);  // Enable I2C1 clock

    GPIOB->MODER |= (2 << (6*2)) | (2 << (7*2));  // AF mode
    GPIOB->OTYPER |= (1 << 6) | (1 << 7);         // Open-drain
    GPIOB->OSPEEDR |= (3 << (6*2)) | (3 << (7*2)); // High speed
    GPIOB->PUPDR |= (1 << (6*2)) | (1 << (7*2));  // Pull-up

    I2C1->CR2 = 16;             // 16MHz
    I2C1->CCR = 80;             // 100kHz (16MHz / (2*80))
    I2C1->TRISE = 17;           // Rise time
    I2C1->CR1 |= (1 << 0);      // Enable I2C
}

// I2C Write Function
void I2C_Write(uint8_t addr, uint8_t reg, uint8_t data) {
    while (I2C1->SR2 & (1 << 1)); // Wait until bus is free
    I2C1->CR1 |= (1 << 8);       // Generate START
    while (!(I2C1->SR1 & (1 << 0))); // Wait for SB
    I2C1->DR = (addr << 1);      // Send address + write
    while (!(I2C1->SR1 & (1 << 1))); // Wait for ADDR
    (void)I2C1->SR2;             // Clear ADDR
    I2C1->DR = reg;              // Send register
    while (!(I2C1->SR1 & (1 << 7))); // Wait for TXE
    I2C1->DR = data;             // Send data
    while (!(I2C1->SR1 & (1 << 7))); // Wait for TXE
    I2C1->CR1 |= (1 << 9);       // Generate STOP
}

// I2C Read Function
void I2C_Read(uint8_t addr, uint8_t reg, uint8_t *data, uint8_t len) {
    while (I2C1->SR2 & (1 << 1)); // Wait until bus is free
    I2C1->CR1 |= (1 << 8);       // Generate START
    while (!(I2C1->SR1 & (1 << 0))); // Wait for SB
    I2C1->DR = (addr << 1);      // Send address + write
    while (!(I2C1->SR1 & (1 << 1))); // Wait for ADDR
    (void)I2C1->SR2;             // Clear ADDR
    I2C1->DR = reg;              // Send register
    while (!(I2C1->SR1 & (1 << 7))); // Wait for TXE
    I2C1->CR1 |= (1 << 8);       // Generate repeated START
    while (!(I2C1->SR1 & (1 << 0))); // Wait for SB
    I2C1->DR = (addr << 1) | 1;  // Send address + read
    while (!(I2C1->SR1 & (1 << 1))); // Wait for ADDR
    (void)I2C1->SR2;             // Clear ADDR
    for (uint8_t i = 0; i < len; i++) {
        if (i == len - 1) I2C1->CR1 &= ~(1 << 10); // NACK last byte
        while (!(I2C1->SR1 & (1 << 6))); // Wait for RXNE
        data[i] = I2C1->DR;
    }
    I2C1->CR1 |= (1 << 9);       // Generate STOP
}

// Initialize USART2 (PA2: TX, PA3: RX)
void USART2_Init(void) {
    RCC->APB1ENR |= (1 << 17);   // Enable USART2 clock
    RCC->AHB1ENR |= (1 << 0);    // Enable GPIOA clock

    GPIOA->MODER |= (2 << (2*2)) | (2 << (3*2));  // AF mode
    GPIOA->AFR[0] |= (7 << (2*4)) | (7 << (3*4)); // AF7 (USART2)

    USART2->BRR = (16 << 4) | 3; // 16MHz / (16*104.1875) ≈ 9600 baud
    USART2->CR1 = (1 << 13) | (1 << 3) | (1 << 2); // UE, TE, RE
}

// USART Send Character
void USART_SendChar(char c) {
    while (!(USART2->SR & (1 << 7))); // Wait for TXE
    USART2->DR = c;
}

// USART Send String
void USART_SendString(const char *str) {
    while (*str) USART_SendChar(*str++);
}

// Initialize IMU (ASM330LHB)
void IMU_Init(void) {
    I2C_Write(ASM330LHB_ADDR, ASM330LHB_CTRL1_XL, 0x40); // ±2g, 104Hz
    I2C_Write(ASM330LHB_ADDR, ASM330LHB_CTRL2_G, 0x40);  // ±250dps, 104Hz
}

// Read Accelerometer Data
void IMU_ReadAccelerometer(float *ax, float *ay, float *az) {
    uint8_t data[6];
    I2C_Read(ASM330LHB_ADDR, ASM330LHB_OUTX_L_A | 0x80, data, 6);
    int16_t raw_x = (int16_t)((data[1] << 8) | data[0]);
    int16_t raw_y = (int16_t)((data[3] << 8) | data[2]);
    int16_t raw_z = (int16_t)((data[5] << 8) | data[4]);
    *ax = raw_x * 0.061f / 1000.0f;
    *ay = raw_y * 0.061f / 1000.0f;
    *az = raw_z * 0.061f / 1000.0f;
}

// Calculate Pitch & Roll
void IMU_CalculateAngles(float ax, float ay, float az, float *pitch, float *roll) {
    *pitch = atan2f(-ax, sqrtf(ay*ay + az*az)) * (180.0f / PI);
    *roll = atan2f(ay, az) * (180.0f / PI);
}

// Main Application
int main(void) {
    SystemClock_Config();
    I2C1_Init();
    USART2_Init();
    IMU_Init();

    float ax, ay, az, pitch, roll;
    char buffer[32];

    while (1) {
        delay(500); // 500ms delay
        IMU_ReadAccelerometer(&ax, &ay, &az);
        IMU_CalculateAngles(ax, ay, az, &pitch, &roll);

        // Format output
        snprintf(buffer, sizeof(buffer), "Pitch: %.2f°, Roll: %.2f°\r\n", pitch, roll);
        USART_SendString(buffer);
    }
}
