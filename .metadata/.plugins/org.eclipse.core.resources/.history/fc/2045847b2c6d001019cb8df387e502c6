#include "registers.h"
#include <math.h>

#define PI 3.14159265358979323846f
#define ASM330LHB_ADDR 0x6B

// IMU register definitions
#define ASM330LHB_WHO_AM_I   0x0F
#define ASM330LHB_CTRL1_XL   0x10
#define ASM330LHB_OUTX_L_A   0x28

// Simple delay function
void delay(uint32_t ms) {
    for(uint32_t i = 0; i < ms * 1000; i++) {
        __asm__("nop");
    }
}

// Initialize system clock to 16MHz (HSI)
void SystemClock_Config(void) {
    // Enable HSI
    RCC_CR |= (1 << 0);
    while(!(RCC_CR & (1 << 1)));

    // Set HSI as system clock
    RCC_CFGR &= ~(3 << 0);
    RCC_CFGR |= (0 << 0);

    // Enable GPIOB and I2C1 clocks
    RCC_AHB1ENR |= (1 << 1); // GPIOB
    RCC_APB1ENR |= (1 << 21); // I2C1
}

// Initialize I2C1
void I2C1_Init(void) {
    // PB6 - I2C1_SCL, PB7 - I2C1_SDA
    GPIOB->MODER |= (2 << (6*2)) | (2 << (7*2)); // Alternate function
    GPIOB->OTYPER |= (1 << 6) | (1 << 7); // Open drain
    GPIOB->OSPEEDR |= (3 << (6*2)) | (3 << (7*2)); // High speed
    GPIOB->PUPDR |= (1 << (6*2)) | (1 << (7*2)); // Pull-up

    // Configure I2C
    I2C1->CR2 = 16; // 16MHz
    I2C1->CCR = 80; // 100kHz (16MHz / (2 * 80) = 100kHz)
    I2C1->TRISE = 17; // 1000ns / (1/16MHz) + 1 = 17
    I2C1->CR1 |= (1 << 0); // Enable I2C
}

// I2C Write function
void I2C_Write(uint8_t addr, uint8_t reg, uint8_t data) {
    // Wait until bus is not busy
    while(I2C1->SR2 & (1 << 1));

    // Generate START
    I2C1->CR1 |= (1 << 8);

    // Wait for SB flag
    while(!(I2C1->SR1 & (1 << 0)));

    // Send address + write
    I2C1->DR = (addr << 1);
    while(!(I2C1->SR1 & (1 << 1)));
    (void)I2C1->SR2; // Clear ADDR

    // Send register address
    I2C1->DR = reg;
    while(!(I2C1->SR1 & (1 << 7)));

    // Send data
    I2C1->DR = data;
    while(!(I2C1->SR1 & (1 << 7)));

    // Generate STOP
    I2C1->CR1 |= (1 << 9);
}

// I2C Read function
void I2C_Read(uint8_t addr, uint8_t reg, uint8_t *data, uint8_t len) {
    // Wait until bus is not busy
    while(I2C1->SR2 & (1 << 1));

    // Generate START
    I2C1->CR1 |= (1 << 8);

    // Wait for SB flag
    while(!(I2C1->SR1 & (1 << 0)));

    // Send address + write
    I2C1->DR = (addr << 1);
    while(!(I2C1->SR1 & (1 << 1)));
    (void)I2C1->SR2; // Clear ADDR

    // Send register address
    I2C1->DR = reg;
    while(!(I2C1->SR1 & (1 << 7)));

    // Generate repeated START
    I2C1->CR1 |= (1 << 8);

    // Wait for SB flag
    while(!(I2C1->SR1 & (1 << 0)));

    // Send address + read
    I2C1->DR = (addr << 1) | 1;
    while(!(I2C1->SR1 & (1 << 1)));
    (void)I2C1->SR2; // Clear ADDR

    // Read data
    for(uint8_t i = 0; i < len; i++) {
        if(i == len - 1) {
            // NACK on last byte
            I2C1->CR1 &= ~(1 << 10);
        }
        while(!(I2C1->SR1 & (1 << 6)));
        data[i] = I2C1->DR;
    }

    // Generate STOP
    I2C1->CR1 |= (1 << 9);
}

// Initialize USART2 for debug output
void USART2_Init(void) {
    // Enable USART2 clock
    RCC_APB1ENR |= (1 << 17);

    // Configure PA2 (TX) and PA3 (RX)
    GPIOA->MODER |= (2 << (2*2)) | (2 << (3*2)); // Alternate function
    GPIOA->AFR[0] |= (7 << (2*4)) | (7 << (3*4)); // AF7 for USART2

    // Configure USART
    USART2->BRR = (16 << 4) | 3; // 16MHz / (16*104.1875) ≈ 9600 baud
    USART2->CR1 = (1 << 13) | (1 << 3) | (1 << 2); // UE, TE, RE
}

// USART send character
void USART_SendChar(char c) {
    while(!(USART2->SR & (1 << 7))); // Wait for TXE
    USART2->DR = c;
}

// USART send string
void USART_SendString(const char *str) {
    while(*str) {
        USART_SendChar(*str++);
    }
}

// Initialize IMU
void IMU_Init(void) {
    // Configure accelerometer (±2g, 104Hz ODR)
    I2C_Write(ASM330LHB_ADDR, ASM330LHB_CTRL1_XL, 0x40);

    // Configure gyroscope (±250dps, 104Hz ODR)
    I2C_Write(ASM330LHB_ADDR, 0x11, 0x40);
}

// Read accelerometer data
void IMU_ReadAccelerometer(float *ax, float *ay, float *az) {
    uint8_t data[6];
    I2C_Read(ASM330LHB_ADDR, ASM330LHB_OUTX_L_A | 0x80, data, 6);

    int16_t raw_x = (int16_t)((data[1] << 8) | data[0]);
    int16_t raw_y = (int16_t)((data[3] << 8) | data[2]);
    int16_t raw_z = (int16_t)((data[5] << 8) | data[4]);

    *ax = raw_x * 0.061f / 1000.0f;
    *ay = raw_y * 0.061f / 1000.0f;
    *az = raw_z * 0.061f / 1000.0f;
}

// Calculate pitch and roll angles
void IMU_CalculateAngles(float ax, float ay, float az, float *pitch, float *roll) {
    *pitch = atan2f(-ax, sqrtf(ay * ay + az * az)) * (180.0f / PI);
    *roll = atan2f(ay, az) * (180.0f / PI);
}

int main(void) {
    SystemClock_Config();
    I2C1_Init();
    USART2_Init();
    IMU_Init();

    float ax, ay, az;
    float pitch, roll;
    uint32_t lastTick = 0;

    while(1) {
        // Simple delay instead of proper timing
        delay(500);

        IMU_ReadAccelerometer(&ax, &ay, &az);
        IMU_CalculateAngles(ax, ay, az, &pitch, &roll);

        // Simple output via USART
        USART_SendString("Pitch: ");
        // You would need to implement float to string conversion here
        USART_SendString(", Roll: ");
        // And here
        USART_SendString("\r\n");
    }
}
